import * as fse from 'fs-extra';
// @ts-ignore
import * as logger from 'haiku-serialization/src/utils/LoggerInstance';
import path = require('path');
import {ExporterInterface} from '..';
import BaseExporter from '../BaseExporter';

// @ts-ignore
import * as rollup from 'rollup';
// @ts-ignore
import * as commonjs from 'rollup-plugin-commonjs';
// @ts-ignore
import * as includePaths from 'rollup-plugin-includepaths';
// @ts-ignore
import * as json from 'rollup-plugin-json';
// @ts-ignore
import * as nodeResolve from 'rollup-plugin-node-resolve';
// @ts-ignore
import * as uglify from 'rollup-plugin-uglify-es';

import {
  getCopyrightNotice,
  getCurrentHumanTimestamp,
  getEmbedName,
  getOrganizationNameOrFallback,
  getStandaloneName,
} from '@haiku/sdk-client/lib/ProjectDefinitions';

import {HaikuBytecode} from '@haiku/core/lib/api';

export enum BundleFormat {
  StandaloneFormat = 'StandaloneFormat',
  EmbedFormat = 'EmbedFormat',
}

export class BundledExporter extends BaseExporter implements ExporterInterface {
  constructor (protected readonly bytecode: HaikuBytecode,
    protected readonly componentFolder: string,
    protected readonly bundleFormat: BundleFormat) {
    super(bytecode, componentFolder);
  }

  createBundle (moduleDirectory: string, input: string, name: string, cb: any) {
    logger.info('[bundler] beginning in basedir', moduleDirectory);

    rollup.rollup({
      input,
      plugins: [
        includePaths({
          include: {
            '@haiku/core': require.resolve('@haiku/core'),
            '@haiku/core/dom': require.resolve('@haiku/core/dom'),
            '@haiku/core/components/controls/Image/code/main/code':
            require.resolve('@haiku/core/components/controls/Image/code/main/code'),
            '@haiku/core/components/controls/Font/code/main/code':
            require.resolve('@haiku/core/components/controls/Font/code/main/code'),
            '@haiku/core/components/controls/Text/code/main/code':
            require.resolve('@haiku/core/components/controls/Text/code/main/code'),
          // Note how we're pointing legacy player to core here
            '@haiku/player': require.resolve('@haiku/core'),
            '@haiku/player/dom': require.resolve('@haiku/core/dom'),
          },
        }),
        nodeResolve({
          jsnext: true,
          main: true,
        }),
        commonjs({
          sourceMap: false,
          extensions: ['.js'],
        }),
        json(),
        uglify(),
      ],
    }).then((bundle: any) => {
      bundle.generate({
        name,
      // Although this is not ideal, we can't force our users to write strict code.
        strict: false,
        format: 'iife',
      }).then(({code}: any) => {
        cb(null, code);
      }).catch((err: any) => {
        cb(err);
      });
    }).catch((err: any) => {
      cb(err);
    });
  }

  generateEmbedBundle (): Promise<string> {
    const projOrganizationName = this.bytecode.metadata.organization;
    const projName = this.bytecode.metadata.project;
    const projPath = this.bytecode.metadata.folder;

    const organizationName = getOrganizationNameOrFallback(projOrganizationName);
    const embedName = getEmbedName(organizationName, projName);

    const autoGeneratedNotice = `This file was autogenerated by Haiku at ${getCurrentHumanTimestamp()}.`;
    const copyrightNotice = getCopyrightNotice(organizationName);

    logger.info('[project folder] bundling code/main/dom-embed.js');

    return new Promise<string>((resolve, reject) => {
      this.createBundle(
        path.join(projPath, 'code/main'),
        path.join(projPath, 'code/main/dom-embed.js'),
        embedName,
        (bundleErr: any, bundledContents: any) => {
          if (bundleErr) {
            return reject(bundleErr);
          }
          logger.info('[project folder] bundling succeeded for', embedName);
          const finalContent = `/** ${autoGeneratedNotice}\n${copyrightNotice}\n*/\n${bundledContents}`;
          return resolve(finalContent);
        },
      );
    });
  }

  generateStandAloneBundle (): Promise<string> {
    const projOrganizationName = this.bytecode.metadata.organization;
    const projName = this.bytecode.metadata.project;
    const projPath = this.bytecode.metadata.folder;

    const organizationName = getOrganizationNameOrFallback(projOrganizationName);
    const standaloneName = getStandaloneName(organizationName, projName);

    const autoGeneratedNotice = `This file was autogenerated by Haiku at ${getCurrentHumanTimestamp()}.`;
    const copyrightNotice = getCopyrightNotice(organizationName);

    logger.info('[project folder] bundling code/main/dom-embed.js');

    return new Promise<string>((resolve, reject) => {
      this.createBundle(
        path.join(projPath, 'code/main'),
        path.join(projPath, 'code/main/dom-standalone.js'),
        standaloneName,
        (bundleErr: any, bundledContents: any) => {
          if (bundleErr) {
            return reject(bundleErr);
          }
          logger.info('[project folder] bundling succeeded for', standaloneName);
          const finalContent = `/** ${autoGeneratedNotice}\n${copyrightNotice}\n*/\n${bundledContents}`;
          return resolve(finalContent);
        },
      );
    });
  }

  writeToFile (filename: string, framerate: number): Promise<void> {

    let bundlePromise = null;
    if (this.bundleFormat === BundleFormat.StandaloneFormat) {
      bundlePromise = this.generateStandAloneBundle();
    } else if (this.bundleFormat === BundleFormat.EmbedFormat) {
      bundlePromise = this.generateEmbedBundle();
    }

    if (!bundlePromise) {
      logger.error(`[formats] Unknown bundle format to export`);
      return fse.writeFile(filename, '// Unknown export format');
    }

    bundlePromise.then((content) => {
      return fse.writeFile(filename, content);
    }).catch((error) => {
      logger.error(`[formats]; caught exception during bundled export type=${this.bundleFormat}: ${error.toString()}`);
    });

    return fse.writeFile(filename, '{}');
  }
}
