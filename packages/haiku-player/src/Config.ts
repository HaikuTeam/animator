import {InteractionMode} from './helpers/interactionModes';

const DEFAULTS = {
  // onHaikuComponentWillInitialize: Function|null
  // Optional lifecycle event hook (see below)
  onHaikuComponentWillInitialize: null,

  // onHaikuComponentDidMount: Function|null
  // Optional lifecycle event hook (see below)
  onHaikuComponentDidMount: null,

  // onHaikuComponentWillMount: Function|null
  // Optional lifecycle event hook (see below)
  onHaikuComponentWillMount: null,

  // onHaikuComponentDidInitialize: Function|null
  // Optional lifecycle event hook (see below)
  onHaikuComponentDidInitialize: null,

  // onHaikuComponentWillUnMount: Function|null
  // Optional lifecycle event hook (see below)
  onHaikuComponentWillUnmount: null,

  // Object of configurable options
  options: {
    // seed: String
    // Random seed used for producing deterministic randomness and namespacing CSS selector behavior
    seed: null,

    // automount: Boolean
    // Whether we should mount the given context to the mount element automatically
    automount: true,

    // autoplay: Boolean
    // Whether we should begin playing the context's animation automatically
    autoplay: true,

    // forceFlush: Boolean
    // Whether to fully flush the component on every single frame (warning: this can severely deoptimize animation)
    forceFlush: false,

    // freeze: Boolean
    // Whether we should freeze timelines and not update per global timeline; useful in headless
    freeze: false,

    // loop: Boolean
    // Whether we should loop the animation, i.e. restart from the first frame after reaching the last
    loop: false,

    // frame: Function|null
    // Optional function that we will call on every frame, provided for developer convenience
    frame: null,

    // clock: Object|null
    // Configuration options that will be passed to the HaikuClock instance. See HaikuClock.js for info.
    clock: {},

    // sizing: String|null
    // Configures the sizing mode of the component; may be 'normal', 'stretch', 'contain', or 'cover'. See
    // HaikuComponent.js for info.
    sizing: null,

    // alwaysComputeSizing: Boolean|null
    // Whether we should always assume the size of the mount will change on every tick. There is a significant
    // performance boost for all non-'normal' sizing modes if we *don't* always assume this, but the size of the
    // mount might change underneath for reasons other than changes in media queries. To be safe, we leave this on
    // by default.
    alwaysComputeSizing: true,

    // preserve3d: String
    // Placeholder for an option to control whether to enable preserve-3d mode in DOM environments. [UNUSED]
    preserve3d: 'auto',

    // contextMenu: String
    // Whether or not the Haiku context menu should display when the component is right-clicked; may be 'enabled' or
    // 'disabled'.
    contextMenu: 'enabled',

    // position: String
    // CSS position setting for the root of the component in DOM; recommended to keep as 'relative'.
    position: 'relative',

    // overflowX: String|null
    // CSS overflow-x setting for the component. Convenience for allows user to specify the overflow setting without
    // needing a wrapper element.
    overflowX: null,

    // overflowY: String|null
    // CSS overflow-x setting for the component. Convenience for allows user to specify the overflow setting without
    // needing a wrapper element.
    overflowY: null,

    // overflow: String|null
    // CSS overflow setting for the component. Use this OR overflowX/overflowY
    overflow: null,

    // mixpanel: String|null
    // If provided, a Mixpanel tracking instance will be created using this string as the API token. The default token
    // is Haiku's production token.
    mixpanel: '6f31d4f99cf71024ce27c3e404a79a61',

    // useWebkitPrefix: boolean
    // Whether to prepend a webkit prefix to transform properties
    useWebkitPrefix: void (0),

    // interactionMode: object
    // Control how this instance handles interaction, e.g. preview mode
    interactionMode: InteractionMode.LIVE,
  },

  // states: Object|null
  // Allow states to be passed in at runtime (ASSIGNED)
  states: null,

  // eventHandlers: Object|null
  // Allow custom event handlers to be passed in at runtime (ASSIGNED)
  eventHandlers: null,

  // timelines: Object|null
  // Allow timelines to be passed in at runtime (ASSIGNED)
  timelines: null,

  // vanities: Object|null
  // Allow vanities to be passed in at runtime (ASSIGNED)
  vanities: null,

  // children: Array|null
  // Children may be passed in, typically via the React adapter
  children: null,
};

function seed() {
  return Math.random().toString(36).slice(2);
}

function build(...argums) {
  const config = {
    onHaikuComponentWillInitialize: null,
    onHaikuComponentDidMount: null,
    onHaikuComponentDidInitialize: null,
    onHaikuComponentWillUnmount: null,
    options: null,
    states: null,
    eventHandlers: null,
    timelines: null,
    template: null,
    vanities: null,
    children: null,
  };

  const args = [...argums];

  args.unshift(DEFAULTS);
  args.forEach((incoming) => {
    if (!incoming || typeof incoming !== 'object') {
      return;
    }

    if (incoming.onHaikuComponentWillInitialize) {
      config.onHaikuComponentWillInitialize = incoming.onHaikuComponentWillInitialize;
    }
    if (incoming.onHaikuComponentDidMount) {
      config.onHaikuComponentDidMount = incoming.onHaikuComponentDidMount;
    }
    if (incoming.onHaikuComponentDidInitialize) {
      config.onHaikuComponentDidInitialize = incoming.onHaikuComponentDidInitialize;
    }
    if (incoming.onHaikuComponentWillUnmount) {
      config.onHaikuComponentWillUnmount = incoming.onHaikuComponentWillUnmount;
    }

    if (incoming.options) {
      config.options = {
        ...config.options,
        ...incoming.options,
      };
    }

    // Hoist any 'options' that might have been passed at the root level up into 'options'
    // e.g. { loop: true } -> { options: { loop: true } }
    for (const key in incoming) {
      if (incoming[key] !== undefined && DEFAULTS.options.hasOwnProperty(key)) {
        config.options[key] = incoming[key];
      }
    }

    if (incoming.states) {
      config.states = {
        ...config.states,
        ...incoming.states,
      };
    }

    // For semantic purposes, also allow 'initialStates' to be passed in
    if (incoming.initialStates && typeof incoming.initialStates === 'object') {
      config.states = {
        ...config.states,
        ...incoming.initialStates,
      };
    }

    if (incoming.eventHandlers) {
      config.eventHandlers = {
        ...config.eventHandlers,
        ...incoming.eventHandlers,
      };
    }
    if (incoming.timelines) {
      config.timelines = {
        ...config.timelines,
        ...incoming.timelines,
      };
    }
    if (incoming.vanities) {
      config.vanities = {
        ...config.vanities,
        ...incoming.vanities,
      };
    }

    if (incoming.children) {
      config.children = incoming.children;
    }
  });

  // Validations:
  if (config.options.overflow && (config.options.overflowX || config.options.overflowY)) {
    console.warn('[haiku player] `overflow` overrides `overflowY`/`overflowX`');
    config.options.overflowX = null;
    config.options.overflowY = null;
  }

  return config;
}

export default {
  build,
  seed,
  DEFAULTS,
};
